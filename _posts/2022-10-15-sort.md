# 排序

冒泡排序（Bubble Sort）：相邻两个元素进行比较，每一轮将最大的元素移到数组的末尾。

选择排序（Selection Sort）：每一轮从未排序的数组中选择最小的元素，并将它放到已排序的数组末尾。

插入排序（Insertion Sort）：将未排序的元素逐个插入到已排序的部分中，将比它大的元素向右移动。

快速排序（Quick Sort）：选取一个 pivot 元素，将数组分成比 pivot 小和比 pivot 大两部分，对这两部分递归进行快速排序，直到数组有序。

归并排序（Merge Sort）：将数组不断地二分为两个子数组，将子数组排序后再合并成一个有序数组，直到整个数组有序。

堆排序（Heap Sort）：使用堆数据结构，将数组转化为一个堆，每次从堆顶取出最大或最小元素，并重新调整堆结构。

希尔排序（Shell Sort）：将数组分成若干个子序列进行插入排序，子序列长度逐渐减小，最终完成排序。

计数排序（Counting Sort）：统计数组中各元素出现的次数，根据元素大小顺序将元素放回到新的数组中。

# 快速排序（二分）
    
    def partition(a,l,r):
        i = l
        j = r
        pivot = a[l]
        while i != j:
            while i < j and a[j] > pivot:
                j -= 1
            while i < j and a[1] <= pivot:
                i += 1
            if i<j:
                a[i],a[j] = a[j],a[i]
            a[l],a[i] = a[i],a[j]
            return i


    def quicksort(a,l,r):
        if l>=r:
            return
        pivot_idx = partition(a,l,r)
        quicksort(a,l,pivot_idx-1)
        quicksort(a,pivot_idx+1,r)

        
# 冒泡排序

    def bubbleSort(arr):
        for i in range(1, len(arr)):
            for j in range(0, len(arr)-i):
                if arr[j] > arr[j+1]:
                    arr[j], arr[j + 1] = arr[j + 1], arr[j]
        return arr


# 选择排序（找最小值）

        def selectionSort(arr):
            for i in range(len(arr) - 1):
                # 记录最小数的索引
                minIndex = i
                for j in range(i + 1, len(arr)):
                    if arr[j] < arr[minIndex]:
                        minIndex = j
                # i 不是最小数时，将 i 和最小数进行交换
                if i != minIndex:
                    arr[i], arr[minIndex] = arr[minIndex], arr[i]
            return arr
            

# 插入排序（都当作最后一个值插入进去）

    def insertionSort(arr):
        for i in range(len(arr)):
            preIndex = i-1
            current = arr[i]
            while preIndex >= 0 and arr[preIndex] > current:
                arr[preIndex+1] = arr[preIndex]
                preIndex-=1
            arr[preIndex+1] = current
        return arr

# 希尔排序
    def shellSort(arr):
        import math
        gap=1
        while(gap < len(arr)/3):
            gap = gap*3+1
        while gap > 0:
            for i in range(gap,len(arr)):
                temp = arr[i]
                j = i-gap
                while j >=0 and arr[j] > temp:
                    arr[j+gap]=arr[j]
                    j-=gap
                arr[j+gap] = temp
            gap = math.floor(gap/3)
        return arr
        
        
# 归并排序
    def mergeSort(arr):
        import math
        if(len(arr)<2):
            return arr
        middle = math.floor(len(arr)/2)
        left, right = arr[0:middle], arr[middle:]
        return merge(mergeSort(left), mergeSort(right))

    def merge(left,right):
        result = []
        while left and right:
            if left[0] <= right[0]:
                result.append(left.pop(0))
            else:
                result.append(right.pop(0));
        while left:
            result.append(left.pop(0))
        while right:
            result.append(right.pop(0));
        return result


# 计数排序

    def countingSort(arr, maxValue):
        bucketLen = maxValue+1
        bucket = [0]*bucketLen
        sortedIndex =0
        arrLen = len(arr)
        for i in range(arrLen):
            if not bucket[arr[i]]:
                bucket[arr[i]]=0
            bucket[arr[i]]+=1
        for j in range(bucketLen):
            while bucket[j]>0:
                arr[sortedIndex] = j
                sortedIndex+=1
                bucket[j]-=1
        return arr
      
